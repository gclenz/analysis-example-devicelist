"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const form_data_1 = __importDefault(require("form-data"));
const sleep_1 = __importDefault(require("../../common/sleep"));
const TagoIOModule_1 = __importDefault(require("../../common/TagoIOModule"));
class Files extends TagoIOModule_1.default {
    isCanceled(cancelled) {
        if (cancelled) {
            throw new Error("Cancelled request");
        }
    }
    async list(query) {
        const result = await this.doRequest({
            path: "/files",
            method: "GET",
            params: {
                path: (query === null || query === void 0 ? void 0 : query.path) || "/",
                pagination_token: query === null || query === void 0 ? void 0 : query.paginationToken,
                qty: (query === null || query === void 0 ? void 0 : query.quantity) || 300,
            },
        });
        return result;
    }
    async uploadBase64(data) {
        const result = await this.doRequest({
            path: "/files",
            method: "POST",
            body: data,
        });
        return result;
    }
    async move(data) {
        const result = await this.doRequest({
            path: "/files",
            method: "PUT",
            body: data,
        });
        return result;
    }
    async delete(files) {
        const result = await this.doRequest({
            path: "/files",
            method: "DELETE",
            body: files,
        });
        return result;
    }
    async checkPermission(file) {
        const result = await this.doRequest({
            path: "/files/permission",
            method: "GET",
            params: {
                file,
            },
        });
        return result;
    }
    async changePermission(files) {
        const result = await this.doRequest({
            path: "/files/permission",
            method: "PUT",
            body: files,
        });
        return result;
    }
    async getPathFromUrl(url) {
        const tagoURL = url.indexOf(".tago.io/file/");
        if (tagoURL === -1) {
            return Promise.reject(`${url} is not a TagoIO files url`);
        }
        return url.slice(tagoURL + 8, url.length);
    }
    async getFileURLSigned(url) {
        const path = await this.getPathFromUrl(url);
        const result = await this.doRequest({
            path,
            method: "GET",
            params: {
                noRedirect: true,
            },
        });
        return result;
    }
    async getFileMD5(url) {
        const path = await this.getPathFromUrl(url);
        const result = await this.doRequest({
            path,
            method: "GET",
            params: {
                md5: true,
                noRedirect: true,
            },
        });
        return result;
    }
    async createMultipartUpload(filename, options) {
        const path = options.dashboard && options.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;
        const result = await this.doRequest({
            path,
            method: "POST",
            body: {
                multipart_action: "start",
                filename,
                public: options.isPublic,
                contentType: options.contentType,
            },
        });
        return result;
    }
    async _uploadPart(filename, uploadID, partNumber, blob, options) {
        const path = options.dashboard && options.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;
        const form = new form_data_1.default();
        form.append("filename", filename);
        form.append("upload_id", uploadID);
        form.append("part", String(partNumber));
        form.append("file", blob, filename);
        form.append("multipart_action", "upload");
        const headers = { "Content-Type": "multipart/form-data" };
        const result = await this.doRequest({
            path,
            method: "POST",
            body: form,
            headers,
        });
        return {
            ETag: result.ETag,
            PartNumber: partNumber,
        };
    }
    async _addToQueue(filename, uploadID, partNumber, blob, options) {
        const maxTries = options.maxTriesForEachChunk || 5;
        const timeout = options.timeoutForEachFailedChunk || 2000;
        let tries = 0;
        while (tries < maxTries) {
            try {
                const result = await this._uploadPart(filename, uploadID, partNumber, blob, options);
                return result;
            }
            catch (ex) {
                await sleep_1.default(timeout);
                tries += 1;
                if (tries >= maxTries) {
                    throw new Error(`Could not upload part number ${partNumber}: ${ex.message}`);
                }
            }
        }
    }
    async _completeMultipartUpload(filename, uploadID, parts, options) {
        const path = options.dashboard && options.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;
        const partsOrdered = parts.sort((a, b) => a.PartNumber - b.PartNumber);
        const headers = { "Content-Type": "multipart/form-data" };
        const result = await this.doRequest({
            path,
            method: "POST",
            body: {
                multipart_action: "end",
                upload_id: uploadID,
                filename,
                parts: partsOrdered,
            },
        });
    }
    async uploadFile(file, filename, options) {
        const MB = Math.pow(2, 20);
        let cancelled = false;
        if (options.onCancelToken) {
            options.onCancelToken(() => {
                cancelled = true;
            });
        }
        this.isCanceled(cancelled);
        const uploadID = await this.createMultipartUpload(filename, options);
        const bytesPerChunk = options.chunkSize || 7 * MB;
        const fileSize = file.length || file.size;
        const chunkAmount = Math.floor(fileSize / bytesPerChunk) + 1;
        const partsPerTime = 3;
        if (chunkAmount > 1 && bytesPerChunk < 5 * MB) {
            throw new Error("Chunk sizes cannot be lower than 5mb if the upload will have multiple parts");
        }
        let offsetStart = 0;
        let offsetEnd = bytesPerChunk;
        let partNumber = 1;
        let error = null;
        const parts = [];
        const promises = [];
        this.isCanceled(cancelled);
        while (offsetStart < fileSize) {
            const sliced = file.slice(offsetStart, offsetEnd);
            while (promises.length >= partsPerTime) {
                this.isCanceled(cancelled);
                if (error) {
                    throw error;
                }
                await sleep_1.default(1000);
            }
            const promise = this._addToQueue(filename, uploadID, partNumber, sliced, options);
            promises.push(promise);
            promise.then((partData) => {
                if (promises.indexOf(promise) >= 0) {
                    promises.splice(promises.indexOf(promise), 1);
                }
                parts.push(partData);
                if (options.onProgress) {
                    const percentage = (parts.length * 100) / chunkAmount;
                    const limitedPercentage = Math.min(percentage, 100).toFixed(2);
                    const roundedPercentage = Number(limitedPercentage);
                    options.onProgress(roundedPercentage);
                }
            });
            promise.catch((err) => {
                error = err;
            });
            this.isCanceled(cancelled);
            await sleep_1.default(500);
            offsetStart = offsetEnd;
            offsetEnd = offsetStart + bytesPerChunk;
            partNumber += 1;
        }
        while (promises.length > 0) {
            this.isCanceled(cancelled);
            if (error) {
                throw error;
            }
            await sleep_1.default(1000);
        }
        this.isCanceled(cancelled);
        for (let i = 0; i < 3; i += 1) {
            try {
                return this._completeMultipartUpload(filename, uploadID, parts, options);
            }
            catch (ex) {
                await sleep_1.default(1000);
                if (i === 2) {
                    throw ex;
                }
            }
        }
    }
}
exports.default = Files;
//# sourceMappingURL=Files.js.map